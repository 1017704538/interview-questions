# 1. JS编译解析流程

## 1.1 JS运行分三步
语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。

## 1.2 预编译执行分五步
1. 创建AO对象(Activation Object 执行期上下文)
2. 找形参和变量声明， 将变量和形参名作为AO属性名，值为undefined。变量声明提升(变量放到后面也不会报错，
只是未定义类型) 如：console.log(a); var a = 10 ;结果为undefined。
3. 将实参值和形参统一(传参)
4. 在函数体找到函数声明(函数声明整体提升 相当于放到程序最前面)
5. 值赋予函数体，执行(声明函数和变量的部分直接不看了)

# 2. 函数作用域和作用域链

## 2.1 函数作用域
> 每个javascript函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供javascript引擎存取，如[[scope]]。
[[scope]]就是函数的作用域，其中存储了执行期上下文的集合。

执行期上下文： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。

## 2.2 作用域链

## 2.3 闭包
> 当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。
闭包问题的解决办法：立即执行函数、let

* 详细解释
1. 当函数执行时，会创建一个称为 “执行期上下文的内部对象(AO)”，执行期上下文定义了一个函数执行时的环境。
2. 函数还会获得它所在作用域的作用域链，是存储函数能够访问的所有执行期上下文的集合，即这个函数能够访问到的东西都是沿着作用域向上查找直到全作用域
3. 函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。
4. 但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。